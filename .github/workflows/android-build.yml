name: Build Chatbox Android APK (Final, Correct Directory & Order)

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build-android-arm64-final:
    name: Build Android (arm64-v8a) - Final Corrected
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js v20
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      # --- 所有缓存步骤，100% 恢复你成功的原版 ---
      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ runner.os }}-node-modules-${{ hashFiles('package-lock.json') }}
      - name: Cache Gradle Wrapper
        uses: actions/cache@v4
        with:
          path: ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-wrapper-${{ hashFiles('**/gradle-wrapper.properties') }}
      - name: Cache auto-generated keystore
        uses: actions/cache@v4
        with:
          path: .github/cache/upload-keystore.jks
          key: ${{ runner.os }}-auto-keystore

      - name: Install dependencies and Add platform
        run: |
          npm install --ignore-scripts
          npx patch-package || true
          if npm install sharp; then npm rebuild sharp || echo "::warning::Sharp rebuild failed"; fi
          if [ ! -d "android" ]; then npx cap add android; fi
          
      - name: Create capacitor.config.ts
        run: echo "import { CapacitorConfig } from '@capacitor/cli'; const config: CapacitorConfig = { appId: 'xyz.chatboxapp.ce', appName: 'Chatbox', webDir: 'release/app/dist/renderer', plugins: { CapacitorHttp: { enabled: true } } }; export default config;" > capacitor.config.ts

      - name: Setup Java and Gradle
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'gradle'
      
      - name: Generate Android assets
        run: npx capacitor-assets generate --android || echo "::warning::Asset generation failed"
      
      - name: Build Web, Fix HTML, and Sync
        run: |
          sed -i "s/target: \\['web', 'electron-renderer'\\]/target: ['web']/" .erb/configs/webpack.config.renderer.prod.ts
          export CHATBOX_BUILD_TARGET=mobile_app
          npm run build:renderer
          python3 -c "import re; f='release/app/dist/renderer/index.html'; c=open(f).read().replace('%PUBLIC_URL%','.'); c=re.sub(r'<script[^>]*src=\"https://www\.googletagmanager\.com[^>]*></script>','',c); open(f,'w').write(c)"
          npx cap sync android

      # --- 核心修复：进入 android 目录执行所有原生文件修改！ ---
      - name: Patch Native Android Files (Correct Directory)
        working-directory: ./android  # <--- 关键！强制指定工作目录
        run: |
          # 1. 注入带日志和权限请求的 MainActivity (路径现在是相对 ./android 的)
          MAIN_JAVA="app/src/main/java/xyz/chatboxapp/ce/MainActivity.java"
          mkdir -p "$(dirname "$MAIN_JAVA")"
          cat > "$MAIN_JAVA" << 'JAVA_EOF'
          package xyz.chatboxapp.ce;
          import android.Manifest;
          import android.content.pm.PackageManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.Environment;
          import android.webkit.ConsoleMessage;
          import android.webkit.WebChromeClient;
          import android.webkit.WebView;
          import androidx.core.app.ActivityCompat;
          import androidx.core.content.ContextCompat;
          import com.getcapacitor.BridgeActivity;
          import java.io.File;
          import java.io.FileWriter;
          import java.io.PrintWriter;
          import java.text.SimpleDateFormat;
          import java.util.Date;
          import java.util.Locale;
          public class MainActivity extends BridgeActivity {
              private static final int REQUEST_STORAGE_PERMISSION = 1001;
              private File logFile;
              private synchronized void log(String message) {
                  android.util.Log.d("ChatboxDebug", message);
                  if (logFile == null) return;
                  try (PrintWriter pw = new PrintWriter(new FileWriter(logFile, true))) {
                      String timestamp = new SimpleDateFormat("HH:mm:ss.SSS", Locale.getDefault()).format(new Date());
                      pw.println(timestamp + " " + message);
                  } catch (Exception e) {}
              }
              private void initializeLogFile() {
                  File targetDir = (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) ? getExternalFilesDir(null) : Environment.getExternalStorageDirectory();
                  if (targetDir != null && (targetDir.exists() || targetDir.mkdirs()) && targetDir.canWrite()) {
                      logFile = new File(targetDir, "chatbox_debug.log");
                      log("✅ Log file path set to: " + logFile.getAbsolutePath());
                  } else { log("❌ ERROR: Cannot get a writable directory for log file."); }
              }
              private void checkAndRequestPermission() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q || ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) {
                      initializeLogFile();
                  } else {
                      ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, REQUEST_STORAGE_PERMISSION);
                  }
              }
              @Override
              public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
                  super.onRequestPermissionsResult(requestCode, permissions, grantResults);
                  if (requestCode == REQUEST_STORAGE_PERMISSION && grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                      log("✅ Storage permission granted by user.");
                      initializeLogFile();
                  } else { log("❌ Storage permission DENIED by user."); }
              }
              @Override
              public void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);
                  checkAndRequestPermission();
                  WebView.setWebContentsDebuggingEnabled(true);
                  if (bridge != null && bridge.getWebView() != null) {
                    bridge.getWebView().setWebChromeClient(new WebChromeClient() {
                        @Override
                        public boolean onConsoleMessage(ConsoleMessage msg) {
                            log("WebView Console: " + msg.message() + " -- (" + msg.sourceId() + ":" + msg.lineNumber() + ")");
                            return true;
                        }
                    });
                  }
              }
          }
          JAVA_EOF
          echo "✅ MainActivity injected inside ./android directory."

          # 2. 修改 AndroidManifest 和网络配置 (路径现在是相对 ./android 的)
          MANIFEST="app/src/main/AndroidManifest.xml"
          if ! grep -q 'android.permission.WRITE_EXTERNAL_STORAGE' "$MANIFEST"; then sed -i '/<manifest/a\    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" android:maxSdkVersion="29" />' "$MANIFEST"; fi
          if ! grep -q 'android:usesCleartextTraffic' "$MANIFEST"; then sed -i '/<application/a\        android:usesCleartextTraffic="true"\n        android:networkSecurityConfig="@xml/network_security_config"' "$MANIFEST"; fi
          NSC_FILE="app/src/main/res/xml/network_security_config.xml"
          mkdir -p "$(dirname "$NSC_FILE")"
          echo '<?xml version="1.0" encoding="utf-8"?><network-security-config><base-config cleartextTrafficPermitted="true"><trust-anchors><certificates src="system" /></trust-anchors></base-config></network-security-config>' > "$NSC_FILE"
          echo "✅ AndroidManifest and Network Config patched inside ./android directory."

      # --- 后续步骤，100% 恢复原版 ---
      - name: Prepare Keystore (original restored)
        run: |
          mkdir -p .github/cache
          if [ -n "${{ secrets.SIGN_KEYSTORE_BASE64 }}" ]; then
            echo "${{ secrets.SIGN_KEYSTORE_BASE64 }}" | base64 -d > android/app/upload-keystore.jks
            cat > android/key.properties <<EOF
          storeFile=upload-keystore.jks
          storePassword=${{ secrets.KEYSTORE_PASSWORD }}
          keyAlias=${{ secrets.KEY_ALIAS }}
          keyPassword=${{ secrets.KEY_PASSWORD }}
          EOF
          else
            if [ -f ".github/cache/upload-keystore.jks" ]; then
              cp .github/cache/upload-keystore.jks android/app/upload-keystore.jks
            else
              keytool -genkey -v -keystore android/app/upload-keystore.jks -keyalg RSA -keysize 2048 -validity 10000 -storepass android -keypass android -alias androiddebugkey -dname "CN=Chatbox,O=Chatbox,C=CN"
              cp android/app/upload-keystore.jks .github/cache/upload-keystore.jks
            fi
            cat > android/key.properties <<EOF
          storeFile=upload-keystore.jks
          storePassword=android
          keyAlias=androiddebugkey
          keyPassword=android
          EOF
          fi

      - name: Configure build.gradle (original restored)
        run: |
          cat > android/app/arm64-config.gradle << 'EOF'
          def keystoreFile = rootProject.file('key.properties'); def keystoreProps = new Properties(); if (keystoreFile.exists()) { keystoreProps.load(new FileInputStream(keystoreFile)) }; android { if (keystoreFile.exists()) { signingConfigs { release { storeFile file(keystoreProps['storeFile']); storePassword keystoreProps['storePassword']; keyAlias keystoreProps['keyAlias']; keyPassword keystoreProps['keyPassword'] } }; buildTypes { release { signingConfig signingConfigs.release } } }; defaultConfig { ndk { abiFilters "arm64-v8a" } } }
          EOF
          if ! grep -q "apply from: 'arm64-config.gradle'" android/app/build.gradle; then
            echo "" >> android/app/build.gradle
            echo "apply from: 'arm64-config.gradle'" >> android/app/build.gradle
          fi

      - name: Build Release APK
        working-directory: ./android # 确保在正确的目录下执行
        run: ./gradlew assembleRelease --stacktrace

      - name: Package APK (original restored)
        id: package_apk
        run: |
          APK_PATH="android/app/build/outputs/apk/release/app-release.apk"
          if [ ! -f "$APK_PATH" ]; then
            APK_PATH=$(find android/app/build/outputs/apk/release -type f -name "*-release.apk" ! -name "*-unsigned.apk" | head -n 1)
          fi
          if [ -z "$APK_PATH" ] || [ ! -f "$APK_PATH" ]; then
            echo "::error::Signed release APK not found!"; ls -lR android/app/build/outputs/apk/release; exit 1
          fi
          VERSION=$(node -p "require('./package.json').version")
          NAME="Chatbox-Patched-Final-${VERSION}-arm64.apk"
          mkdir -p artifacts
          cp "$APK_PATH" "artifacts/$NAME"
          echo "apk_name=$NAME" >> $GITHUB_OUTPUT

      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: chatbox-android-patched-apk
          path: artifacts/${{ steps.package_apk.outputs.apk_name }}
          if-no-files-found: error
