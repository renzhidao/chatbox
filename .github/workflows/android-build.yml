name: Build Chatbox Android APK (Final, Corrected & Fully Restored)

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build-android-arm64-final:
    name: Build Android (arm64-v8a) - Final Corrected
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js v20
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ runner.os }}-node-modules-${{ hashFiles('package-lock.json') }}
      - name: Cache Gradle Wrapper
        uses: actions/cache@v4
        with:
          path: ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-wrapper-${{ hashFiles('**/gradle-wrapper.properties') }}
      - name: Cache auto-generated keystore
        uses: actions/cache@v4
        with:
          path: .github/cache/upload-keystore.jks
          key: ${{ runner.os }}-auto-keystore

      - name: Install dependencies and Add platform
        run: |
          npm install --ignore-scripts
          npx patch-package || true
          if npm install sharp; then npm rebuild sharp || echo "::warning::Sharp rebuild failed"; fi
          if [ ! -d "android" ]; then npx cap add android; fi
          
      - name: Create capacitor.config.ts
        run: |
          cat > capacitor.config.ts << 'EOF'
          import { CapacitorConfig } from '@capacitor/cli';
          const config: CapacitorConfig = { appId: 'xyz.chatboxapp.ce', appName: 'Chatbox', webDir: 'release/app/dist/renderer', plugins: { CapacitorHttp: { enabled: true } } };
          export default config;
          EOF

      - name: Setup Java and Gradle
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'gradle'
      
      # --- [LOGO FIX] 修正了Logo生成和同步的顺序 ---
      - name: Build Web, Fix HTML, Sync, then Generate Assets
        run: |
          # 1. 构建 Web 内容
          sed -i "s/target: \\['web', 'electron-renderer'\\]/target: ['web']/" .erb/configs/webpack.config.renderer.prod.ts
          export CHATBOX_BUILD_TARGET=mobile_app
          npm run build:renderer
          
          # 2. 修正 HTML
          python3 -c "import re; f='release/app/dist/renderer/index.html'; c=open(f).read().replace('%PUBLIC_URL%','.'); c=re.sub(r'<script[^>]*src=\"https://www\.googletagmanager\.com[^>]*></script>','',c); open(f,'w').write(c)"
          
          # 3. 先同步，这会重置图标为默认
          npx cap sync android
          
          # 4. 最后生成资产，用您的自定义图标覆盖掉默认图标
          npx capacitor-assets generate --android || echo "::warning::Asset generation failed"

      - name: Patch Native Android Files
        run: |
          MAIN_JAVA="android/app/src/main/java/xyz/chatboxapp/ce/MainActivity.java"
          mkdir -p "$(dirname "$MAIN_JAVA")"
          cat > "$MAIN_JAVA" << 'JAVA_EOF'
          package xyz.chatboxapp.ce;
          import android.Manifest;
          import android.content.pm.PackageManager;
          import android.os.Build;
          import android.os.Bundle;
          import android.os.Environment;
          import android.webkit.ConsoleMessage;
          import android.webkit.WebChromeClient;
          import android.webkit.WebView;
          import androidx.core.app.ActivityCompat;
          import androidx.core.content.ContextCompat;
          import com.getcapacitor.BridgeActivity;
          import java.io.File;
          import java.io.FileWriter;
          import java.io.PrintWriter;
          import java.text.SimpleDateFormat;
          import java.util.Date;
          import java.util.Locale;
          public class MainActivity extends BridgeActivity {
              private static final int REQUEST_STORAGE_PERMISSION = 1001;
              private File logFile;
              private synchronized void log(String message) {
                  android.util.Log.d("ChatboxDebug", message);
                  if (logFile == null) return;
                  try (PrintWriter pw = new PrintWriter(new FileWriter(logFile, true))) {
                      String timestamp = new SimpleDateFormat("HH:mm:ss.SSS", Locale.getDefault()).format(new Date());
                      pw.println(timestamp + " " + message);
                  } catch (Exception e) {}
              }
              private void initializeLogFile() {
                  File targetDir = (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) ? getExternalFilesDir(null) : Environment.getExternalStorageDirectory();
                  if (targetDir != null && (targetDir.exists() || targetDir.mkdirs()) && targetDir.canWrite()) {
                      logFile = new File(targetDir, "chatbox_debug.log");
                      log("✅ Log file path set to: " + logFile.getAbsolutePath());
                  } else { log("❌ ERROR: Cannot get a writable directory for log file."); }
              }
              private void checkAndRequestPermission() {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q || ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) {
                      initializeLogFile();
                  } else {
                      ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, REQUEST_STORAGE_PERMISSION);
                  }
              }
              @Override
              public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
                  super.onRequestPermissionsResult(requestCode, permissions, grantResults);
                  if (requestCode == REQUEST_STORAGE_PERMISSION && grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                      log("✅ Storage permission granted by user.");
                      initializeLogFile();
                  } else { log("❌ Storage permission DENIED by user."); }
              }
              @Override
              public void onCreate(Bundle savedInstanceState) {
                  super.onCreate(savedInstanceState);
                  checkAndRequestPermission();
                  WebView.setWebContentsDebuggingEnabled(true);
                  if (bridge != null && bridge.getWebView() != null) {
                    bridge.getWebView().setWebChromeClient(new WebChromeClient() {
                        @Override
                        public boolean onConsoleMessage(ConsoleMessage msg) {
                            log("WebView Console: " + msg.message() + " -- (" + msg.sourceId() + ":" + msg.lineNumber() + ")");
                            return true;
                        }
                    });
                  }
              }
          }
          JAVA_EOF
          echo "✅ MainActivity injected from root."

          MANIFEST="android/app/src/main/AndroidManifest.xml"
          if ! grep -q 'android.permission.WRITE_EXTERNAL_STORAGE' "$MANIFEST"; then sed -i '/<manifest/a\    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" android:maxSdkVersion="29" />' "$MANIFEST"; fi
          if ! grep -q 'android:usesCleartextTraffic' "$MANIFEST"; then sed -i '/<application/a\        android:usesCleartextTraffic="true"\n        android:networkSecurityConfig="@xml/network_security_config"' "$MANIFEST"; fi
          NSC_FILE="android/app/src/main/res/xml/network_security_config.xml"
          mkdir -p "$(dirname "$NSC_FILE")"
          echo '<?xml version="1.0" encoding="utf-8"?><network-security-config><base-config cleartextTrafficPermitted="true"><trust-anchors><certificates src="system" /></trust-anchors></base-config></network-security-config>' > "$NSC_FILE"
          echo "✅ AndroidManifest and Network Config patched from root."

      - name: Prepare Keystore (Corrected)
        run: |
          KEYSTORE_DIR="android/app"
          mkdir -p .github/cache
          mkdir -p "$KEYSTORE_DIR"
          if [ -n "${{ secrets.SIGN_KEYSTORE_BASE64 }}" ]; then
            echo "✅ Using secrets to create keystore."
            echo "${{ secrets.SIGN_KEYSTORE_BASE64 }}" | base64 -d > "$KEYSTORE_DIR/upload-keystore.jks"
            cat > "$KEYSTORE_DIR/key.properties" <<EOF
          storeFile=upload-keystore.jks
          storePassword=${{ secrets.KEYSTORE_PASSWORD }}
          keyAlias=${{ secrets.KEY_ALIAS }}
          keyPassword=${{ secrets.KEY_PASSWORD }}
          EOF
          else
            echo "✅ Using cached or new debug keystore."
            if [ -f ".github/cache/upload-keystore.jks" ]; then
              cp .github/cache/upload-keystore.jks "$KEYSTORE_DIR/upload-keystore.jks"
            else
              keytool -genkey -v -keystore "$KEYSTORE_DIR/upload-keystore.jks" -keyalg RSA -keysize 2048 -validity 10000 -storepass android -keypass android -alias androiddebugkey -dname "CN=Chatbox,O=Chatbox,C=CN"
              cp "$KEYSTORE_DIR/upload-keystore.jks" .github/cache/upload-keystore.jks
            fi
            cat > "$KEYSTORE_DIR/key.properties" <<EOF
          storeFile=upload-keystore.jks
          storePassword=android
          keyAlias=androiddebugkey
          keyPassword=android
          EOF
          fi
          echo "✅ Keystore and key.properties created in $KEYSTORE_DIR"

      - name: Configure build.gradle (Corrected)
        run: |
          cat > android/app/arm64-config.gradle << 'EOF'
          def keystorePropertiesFile = file('key.properties')
          if (keystorePropertiesFile.exists()) {
              def keystoreProps = new Properties()
              keystoreProps.load(new FileInputStream(keystorePropertiesFile))
              
              android {
                  signingConfigs {
                      release {
                          storeFile file(keystoreProps['storeFile'])
                          storePassword keystoreProps['storePassword']
                          keyAlias keystoreProps['keyAlias']
                          keyPassword keystoreProps['keyPassword']
                      }
                  }
                  buildTypes {
                      release {
                          signingConfig signingConfigs.release
                      }
                  }
                  defaultConfig { 
                      ndk { 
                          abiFilters "arm64-v8a" 
                      } 
                  }
              }
          }
          EOF
          if ! grep -q "apply from: 'arm64-config.gradle'" android/app/build.gradle; then
            echo "" >> android/app/build.gradle
            echo "apply from: 'arm64-config.gradle'" >> android/app/build.gradle
          fi
          echo "✅ build.gradle configured to use arm64-config.gradle."

      - name: Build Release APK
        working-directory: ./android
        run: ./gradlew assembleRelease --stacktrace

      - name: Package APK (Restored with robust logic)
        id: package_apk
        run: |
          APK_PATH="android/app/build/outputs/apk/release/app-release.apk"
          if [ ! -f "$APK_PATH" ]; then
            echo "Standard 'app-release.apk' not found. Searching for other release APKs..."
            APK_PATH=$(find android/app/build/outputs/apk/release -type f -name "*-release.apk" ! -name "*-unsigned.apk" | head -n 1)
          fi
          if [ -z "$APK_PATH" ] || [ ! -f "$APK_PATH" ]; then
            echo "::error::Signed release APK not found!"
            ls -lR android/app/build/outputs/apk/release
            exit 1
          fi
          echo "Found APK at: $APK_PATH"
          VERSION=$(node -p "require('./package.json').version")
          NAME="Chatbox-Patched-Final-${VERSION}-arm64.apk"
          mkdir -p artifacts
          cp "$APK_PATH" "artifacts/$NAME"
          echo "apk_name=$NAME" >> $GITHUB_OUTPUT

      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: chatbox-android-patched-apk
          path: artifacts/${{ steps.package_apk.outputs.apk_name }}
          if-no-files-found: error
